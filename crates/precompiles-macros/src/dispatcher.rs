//! Dispatcher generation for contract macro.
//!
//! This module generates the `trait Precompile` implementation that routes
//! EVM calldata to trait methods based on function selectors.

use crate::{
    FieldInfo,
    interface::{FunctionKind, InterfaceFunction},
};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::Ident;

/// Generates the `Precompile` implementation for the contract.
pub(crate) fn gen_dispatcher(
    strukt: &Ident,
    interface_idents: &[Ident],
    all_funcs: &[InterfaceFunction],
    _fields: &[FieldInfo],
) -> TokenStream {
    // Create a mapping from interface identifier to trait name
    let num_interfaces = interface_idents.len();
    let interface_map: Vec<(String, Ident)> = interface_idents
        .iter()
        .map(|interface_ident| {
            let trait_name = if num_interfaces == 1 {
                // single interface: `<ContractName>Call`
                format_ident!("{}Call", strukt)
            } else {
                // multiple interfaces: `<ContractName>_<InterfaceName>Call`
                format_ident!("{}_{}", strukt, interface_ident)
            };
            (interface_ident.to_string(), trait_name)
        })
        .collect();

    // Generate match arms for each function
    let match_arms: Vec<TokenStream> = all_funcs
        .iter()
        .map(|func| gen_match_arm(strukt, &interface_map, func))
        .collect();

    quote! {
        impl<'a, S: crate::storage::PrecompileStorageProvider> crate::Precompile for #strukt<'a, S> {
            fn call(&mut self, calldata: &[u8], msg_sender: ::alloy::primitives::Address) -> ::revm::precompile::PrecompileResult {
                let selector: [u8; 4] = calldata
                    .get(..4)
                    .ok_or_else(|| {
                        ::revm::precompile::PrecompileError::Other(
                            "Invalid input: missing function selector".to_string()
                        )
                    })?
                    .try_into()
                    .map_err(|_| {
                        ::revm::precompile::PrecompileError::Other(
                            "Invalid selector format".to_string()
                        )
                    })?;

                match selector {
                    #(#match_arms)*
                    _ => Err(::revm::precompile::PrecompileError::Other(
                        "Unknown function selector".to_string()
                    )),
                }
            }
        }
    }
}

/// Generates calldata decode logic with gas-charged error handling.
fn gen_decode_or_revert(call_type: &TokenStream, gas_value: &TokenStream) -> TokenStream {
    quote! {
        let call = match <#call_type as ::alloy::sol_types::SolCall>::abi_decode(calldata) {
            Ok(call) => call,
            Err(_) => {
                return Ok(::revm::precompile::PrecompileOutput::new_reverted(
                    #gas_value,
                    ::alloy::primitives::Bytes::new()
                ));
            }
        };
    }
}

/// Generates the encoder function for return values.
fn gen_encoder(call_type: &TokenStream, is_void: bool) -> TokenStream {
    if is_void {
        quote! { |()| ::alloy::primitives::Bytes::new() }
    } else {
        quote! { |ret| <#call_type as ::alloy::sol_types::SolCall>::abi_encode_returns(&ret).into() }
    }
}

/// Generates an individual match arm for a function.
fn gen_match_arm(
    struct_name: &Ident,
    interface_map: &[(String, Ident)],
    func: &InterfaceFunction,
) -> TokenStream {
    let call_type = &func.call_type_path;
    let method_name = format_ident!("{}", func.name);

    // Determine which interface trait this function belongs to
    // Remove whitespace from TokenStream string representation for reliable matching
    let call_type_str = format!("{call_type}").replace(" ", "");
    let trait_name = interface_map
        .iter()
        .find(|(interface_path, _)| {
            call_type_str.starts_with(interface_path)
                && call_type_str[interface_path.len()..].starts_with("::")
        })
        .map(|(_, trait_name)| trait_name.clone())
        .unwrap_or_else(|| {
            // Fallback: extract interface from call_type
            let interface_name = call_type_str.split("::").next().unwrap_or("Unknown").trim();
            format_ident!("{}_{}", struct_name, interface_name)
        });

    // Extract parameter field accessors from the call struct
    // Use solidity (camelCase) names to match struct fields generated by the `sol!` macro
    let param_fields = func.params.iter().map(|(param_name, _)| {
        let field_name = format_ident!("{}", param_name.sol);
        quote! { call.#field_name }
    });

    let gas_value = match &func.gas {
        Some(gas) => quote! { #gas },
        None => match func.kind() {
            FunctionKind::Metadata => quote! { crate::METADATA_GAS },
            FunctionKind::View => quote! { crate::VIEW_FUNC_GAS },
            FunctionKind::Mutate | FunctionKind::MutateVoid => quote! { crate::MUTATE_FUNC_GAS },
        },
    };

    match func.kind() {
        FunctionKind::Metadata => {
            let encoder = gen_encoder(call_type, false);
            quote! {
                #call_type::SELECTOR => {
                    use crate::IntoPrecompileResult as _;
                    (|| #trait_name::#method_name(self))()
                        .into_precompile_result(#gas_value, #encoder)
                }
            }
        }
        FunctionKind::View => {
            let decode_logic = gen_decode_or_revert(call_type, &gas_value);
            let encoder = gen_encoder(call_type, false);
            let call_expr = if func.params.is_empty() {
                quote! { #trait_name::#method_name(self) }
            } else {
                quote! { #trait_name::#method_name(self, #(#param_fields),*) }
            };
            quote! {
                #call_type::SELECTOR => {
                    use crate::IntoPrecompileResult as _;
                    #decode_logic
                    #call_expr.into_precompile_result(#gas_value, #encoder)
                }
            }
        }
        FunctionKind::Mutate => {
            let decode_logic = gen_decode_or_revert(call_type, &gas_value);
            let encoder = gen_encoder(call_type, false);
            let call_expr = if func.params.is_empty() {
                quote! { #trait_name::#method_name(self, msg_sender) }
            } else {
                quote! { #trait_name::#method_name(self, msg_sender, #(#param_fields),*) }
            };
            quote! {
                #call_type::SELECTOR => {
                    use crate::IntoPrecompileResult as _;
                    #decode_logic
                    #call_expr.into_precompile_result(#gas_value, #encoder)
                }
            }
        }
        FunctionKind::MutateVoid => {
            let decode_logic = gen_decode_or_revert(call_type, &gas_value);
            let encoder = gen_encoder(call_type, true);
            let call_expr = if func.params.is_empty() {
                quote! { #trait_name::#method_name(self, msg_sender) }
            } else {
                quote! { #trait_name::#method_name(self, msg_sender, #(#param_fields),*) }
            };
            quote! {
                #call_type::SELECTOR => {
                    use crate::IntoPrecompileResult as _;
                    #decode_logic
                    #call_expr.into_precompile_result(#gas_value, #encoder)
                }
            }
        }
    }
}
